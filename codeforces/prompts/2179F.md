# Role: 算法竞赛资深专家 (Competitive Programming Grandmaster)

## Profile
你是一位精通算法竞赛（OI/ACM）的顶级专家，擅长使用最严谨、最高效的方法解决复杂的计算问题。你对 https://oi-wiki.org/ 中的所有算法体系（动态规划、图论、数论、计算几何等）有深入研究，能够根据题目限制给出最优解。

## Input Context
用户将提供以下信息：
1. **题目描述**：核心逻辑与目标。
   F. Blackslex and Another RGB Walking

time limit per test: 5 seconds

memory limit per test: 256 megabytes

input: standard input

output: standard output

This is a run-twice (communication) problem.

There are two players: Player A (Agent) and Player B (Blackslex). The jury will first interact with player A. After player A ends their interaction, the jury will interact with player B. Note that player A and player B may not directly pass information to each other; both players are only able to send information or receive information from the jury, but they may agree on the strategy they will use to communicate.

The Penguin Republic is a [**bipartite**](https://en.wikipedia.org/wiki/Bipartite_graph) connected undirected graph $G$ with $n$ vertices and $m$ edges. Blackslex is going to conduct forbidden field research at vertex $1$. Due to travel restrictions, he will be dropped off at an unknown vertex $v$ ($2 \leq v \leq n$). He must get to vertex $1$ while having no information on the graph.

For his journey, he has bribed a penguin agent and agreed to some communication strategy using the following method; the agent will discreetly mark each vertex in one of the three colors: red, green, or blue. From Blackslex's perspective, he will see only the color $c_i$ of each neighbor $u_i$ ($1 \leq i \leq d(v)$$^{\text{∗}}$) of $v$. He must choose some $j$ ($1 \leq j \leq d(v)$) and move to vertex $u_j$ such that he is closer to vertex $1$.

Note that the neighbors are arbitrarily ordered. He sees only the colors of the neighboring vertices, and not the vertex that he is on. Additionally, he does not know the index of the vertex he's on, the neighboring vertices, or any other vertex.

Your task is to implement the strategy for both the agent and Blackslex. For the agent, you must color each vertex in one of the three colors. For Blackslex, you are given $q$ queries. In each query, you are dropped off at an arbitrary and unknown vertex $v$ and given the color of the neighboring vertices. You must determine a vertex to go to such that you are closer to vertex $1$.

$^{\text{∗}}$The number of neighbors of vertex $v$.

**Input**

Your code will be ran exactly two times on each test. On the first run, you will be Player A (Agent), and on the second Player B (Blackslex).

**First Run Input**

The first line of the input contains the string first. The purpose of this is so your program recognizes that this is its first run, and it should act as Player A.

Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 10^4$). The description of the test cases follows.

The first line of each test case contains two integers $n$ and $m$ ($2 \leq n \leq 10^5$, $n-1 \leq m \leq 10^5$) — the number of vertices and edges respectively.

The following $m$ lines contain information about the edges. The $i$\-th ($1 \leq i \leq m$) line has two integers $a_i$ and $b_i$. ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — vertex $a_i$ is connected to vertex $b_i$ by edge $i$.

It is guaranteed that:

-   The sum of $n$ and the sum of $m$ does not exceed $10^5$ over all test cases.
-   The graph in each test case is bipartite and connected. It has no duplicate edges and no self-loops.

**Second Run Input**

The first line of the input contains the string second. The purpose of this is so your program recognizes that this is its second run, and it should act as Player B.

Each test contains multiple test cases. The first line contains the number of test cases $t$ ($1 \leq t \leq 10^4$) — the same value of $t$ in the first run. The description of the test cases follows.

The first line of each test case contains one integer $q$ ($1 \leq q \leq 10^5$) — the number of queries in this test case.

The first line of each query contains one integer $d(v)$ ($1 \leq d(v) \leq 10^5$) — the number of neighbors of the vertex $v$ that Blackslex is currently on.

The next line of each query contains a string $c$ of length $d(v)$ — the $i$\-th ($1 \leq i \leq d(v)$) character of the string is the color of the neighboring vertex $u_i$. The characters in the string are r, g, or b representing red, green, or blue.

It is guaranteed that:

-   The sum of $q$ does not exceed $10^5$ over all queries in all test cases.
-   The sum of $d(v)$ does not exceed $2 \cdot 10^5$ over all queries in all test cases.
-   $v \neq 1$

The input of the second run is not adaptive. In other words, the input of the second run will not change in different runs.

**Hacks**

To make hacks, use the following format:

The first line contains one integer $t$ ($1 \leq t \leq 10^4$) — the number of test cases.

The description of the test cases for the first run follows.

The first line of each test case contains two integers $n$ and $m$ ($2 \leq n \leq 10^5$, $n-1 \leq m \leq 10^5$) — the number of vertices and edges respectively.

The following $m$ lines contain information about the edges. The $i$\-th ($1 \leq i \leq m$) line has two integers $a_i$ and $b_i$. ($1 \leq a_i, b_i \leq n$, $a_i \neq b_i$) — vertex $a_i$ is connected to vertex $b_i$ by edge $i$.

After that, the description of the test cases for the second run follows.

The first line of each test case contains one integer $q$ ($1 \leq q \leq 10^5$) — the number of queries in this test case.

The first line of each query contains one integer $v$ ($2 \leq v \leq n$) — the vertex the Blackslex is dropped off.

The second line of each query contains $d(v)$ integers $p_1, p_2, \ldots, p_{d(v)}$ ($1 \leq p_i \leq d(v)$, each number in $p$ is distinct) — the ordering of the neighbor is as follows; let $q_1 &lt; q_2 &lt; \ldots &lt; q_{d(v)}$ be the neighbors of $v$, then the input order of the neighbor is $u_i = q_{p_i}$.

It must hold that:

-   The sum of $n$ and the sum of $m$ does not exceed $10^5$ over all test cases in the first run.
-   The graph in each test case is bipartite and connected. It has no duplicate edges and no self-loops.
-   The sum of $q$ does not exceed $10^5$ over all queries in all test cases.
-   The sum of $d(v)$ does not exceed $2 \cdot 10^5$ over all test cases in the second run.

**Output**

For the first run, for each test case, output a single string $s$ of length $n$ — $s_i$ ($1 \leq i \leq n$) is the color of the $i$\-th vertex, painted by the agent. The characters in the string are r, g, or b representing red, green, or blue.

For the second run, for each query in each test case, output a single integer $j$ ($1 \leq j \leq d(v)$) — $u_j$ is the neighboring vertex that Blackslex will go to next.
2. **示例数据**：输入输出样例。
   Input
   first
   2
   7 8
   1 2
   1 6
   3 2
   4 2
   6 4
   4 7
   5 6
   5 7

4 4
1 2
1 3
4 2
4 3
Output
rrgbggr
rbbb

-----
Input
second
2
2
3
grr
3
gbr

1
2
rb
Output
1
3
1
-----
**Note**

![](https://espresso.codeforces.com/ef9c0599cdc87e984f9d086aea695eb05aa1a01f.png) Graph and coloring of both tests.

In the sample, there are two test cases. The graph and the sample's vertex coloring are demonstrated in the picture above.

In the second run, the first test case has two queries.

The first query is on vertex $4$ with the neighbors ordered as vertex $6$, $2$, and $7$. Choosing the first neighbor is walking to vertex $6$.

The second query is on vertex $6$ with the neighbors ordered as vertex $5$, $4$, and $1$. Choosing the third neighbor is walking to vertex $1$.

The second test case has a single query on vertex $2$ with the neighbors ordered as vertex $1$ and $4$. Choosing the first neighbor is walking to vertex $1$.

Note that the empty lines are made to assist reading. Actual test cases do not have empty lines.

\[In-contest only\] Link to image in case of the image not loading: [https://ibb.co/yFZS16vj](https://ibb.co/yFZS16vj)
3. **约束条件**：重点关注时间限制 (Time Limit)：5s 和空间限制 (Memory Limit): 256mb。
4. **关键思路提示**:

## Execution Logic
请按以下步骤思考：
1. **深度解析与模型转化**：
    - 识别问题本质（例如：是否为“贡献法”计数？是否需“离散化+线段树”？）。
    - **对齐知识库**：明确指出涉及 OI-Wiki 中的具体模块（如：图论 -> 最短路 -> Dijkstra）。
2. **时空复杂度精确评估**：
    - 使用 $LaTeX$ 公式列出复杂度。
    - **代入量化分析**：若 $N=2 \cdot 10^5$，评估 $O(N \log N) \approx 3.6 \cdot 10^6$ 次运算，在 1s 限制下的安全裕度。
3. **Go 1.22.2 竞赛级实现细节**：
    - **Fast I/O**：除非数据量极小，否则必须使用 `bufio.NewScanner` 或 `bufio.NewReader`。
    - **内存分配**：在高频递归或大数组中注意 `make` 的预分配，避免频繁 GC。
    - **递归深度**：若涉及深层 DFS，考虑手动模拟栈或注意栈溢出风险。
4. **测试用例 Dry Run**：在脑海中运行示例数据，确认识别到题目中的“坑”（如：多组输入是否清空数组、长整型溢出等）。
5. **代码风格**：需要尽可能模仿人类选手风格，可能存在命名错误/命名不具备意义等疏漏，尽可能绕过AI检测



## Output Format
1. **【算法选型】**：简述原因并引用 OI-Wiki 知识点。
2. **【复杂度分析】**：列出具体公式及针对约束条件的通过可行性说明。
3. **【代码实现】**：
    - 提供完整、可运行的代码。
    - **必须包含 Fast I/O 模板**。
    - 关键逻辑行内注释。
4. **【避坑指南】**：针对该特定题目的数据范围，提醒容易出错的边界条件（如 $ans$ 初始值、取模运算等）。